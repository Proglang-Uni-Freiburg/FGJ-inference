import FGJ_AST as FGJ
import FGJ_GT_AST as FGJ_GT
import FGJ_auxiliary_typing as AUX

from typing import Generator, Any, Optional
from frozenlist import FrozenList
from itertools import product


class NoSolutionFound(Exception):
    pass


def fresh(name: str) -> Generator[FGJ_GT.TypeVarA, Any, None]:
    """
    Create an infinite amount of TypeVarA with different names.
    -> name + 0, name + 1, ...
    """
    count = 0
    while True:
        yield FGJ_GT.TypeVarA(name + str(count))
        count += 1


def freshVar(name: str) -> Generator[FGJ.TypeVar, Any, None]:
    """
    Create an infinite amount of TypeVar with different names.
    -> name + 0, name + 1, ...
    """
    count = 0
    while True:
        yield FGJ.TypeVar(name + str(count))
        count += 1


def is_solved_form(C: set[FGJ_GT.sc]) -> bool:
    """
    Returns True if the constraintset only contains constraints wich are in solved form.
    a < b
    a = b
    a < C<Ts>
    a = C<Ts> with a not in Ts
    In case 3 and 4 the type variable a does not appear on the left of another
    constraint of the form 3 or 4.
    """
    lst: list[str] = list()
    for constraint in C:
        match constraint:
            case FGJ_GT.SubTypeC(FGJ_GT.TypeVarA(_), FGJ_GT.TypeVarA(_)):
                pass
            case FGJ_GT.EqualC(FGJ_GT.TypeVarA(_), FGJ_GT.TypeVarA(_)):
                pass
            case FGJ_GT.SubTypeC(FGJ_GT.TypeVarA(a), FGJ.NonTypeVar(_)) if a not in lst:
                lst.append(a)
            case FGJ_GT.EqualC(FGJ_GT.TypeVarA(a), FGJ.NonTypeVar(_)) if a not in lst and not occoursIn(FGJ_GT.TypeVarA(a), constraint.t2):
                lst.append(a)
            case _:
                return False
    return True


def gen_C_prime(C: FGJ_GT.C, oc_to_ord: Optional[dict[FGJ_GT.oc, list[list[FGJ_GT.sc]]]] = None) -> Generator[set[FGJ_GT.sc], Any, Any]:
    """
    Creates an own Constraint for every or-Constraint in the given C.
    Only contains simple constraints.
    If 'env' is given the order of constraints generated by expandLB is preserved.
    """
    sc_set: set[FGJ_GT.sc] = set()
    oc_list: list[list[list[FGJ_GT.sc]]] = list()
    for c in C:
        match c:
            case FGJ_GT.SubTypeC():
                sc_set.add(c)
            case FGJ_GT.EqualC():
                sc_set.add(c)
            case _:
                if oc_to_ord and c in oc_to_ord:
                    oc_list.append(oc_to_ord[c])
                else:
                    oc_list.append([[sci for sci in oci] for oci in c])

    for comb in product(*oc_list):
        out = sc_set.copy()
        for lst in comb:
            for elem in lst:
                out.add(elem)
        yield out


def substitue_typeVarA(t: FGJ.Type, a: FGJ_GT.TypeVarA, t_old: FGJ.Type) -> FGJ.Type:
    """
    [T/a]T'
    """
    match t_old:
        case FGJ_GT.TypeVarA(a.name):
            return t
        case FGJ.NonTypeVar(n, ts):
            return FGJ.NonTypeVar(n, FrozenList([substitue_typeVarA(t, a, ti) for ti in ts]))
        case _:
            return t_old


def substitute_typeVarAs(ys: list[FGJ.TypeVar], ass: list[FGJ_GT.TypeVarA], t: FGJ.Type) -> FGJ.Type:
    """
    [Ys/as]T
    """
    for yi, ai in zip(ys, ass):
        t = substitue_typeVarA(yi, ai, t)
    return t


def substConstraint(t: FGJ.Type, a: FGJ_GT.TypeVarA, C: set[FGJ_GT.sc]) -> set[FGJ_GT.sc]:
    """
    [T/a]C
    """
    newC = set()
    for constraint in C:
        match constraint:
            case FGJ_GT.EqualC(t1, t2):
                newC.add(FGJ_GT.EqualC(substitue_typeVarA(t, a, t1), substitue_typeVarA(t, a, t2)))
            case FGJ_GT.SubTypeC(t1, t2):
                newC.add(FGJ_GT.SubTypeC(substitue_typeVarA(t, a, t1), substitue_typeVarA(t, a, t2)))
    return newC


def occoursIn(a: FGJ_GT.TypeVarA, b: FGJ.Type) -> bool:
    """
    Returns True if a is in T
    """
    match b:
        case FGJ_GT.TypeVarA(a.name):
            return True
        case FGJ.NonTypeVar(_, ts):
            return any([occoursIn(a, ti) for ti in ts])
        case _:
            return False


def genericSupertype(C: str, ts: FrozenList[FGJ.Type], D: str, env: FGJ.Delta, CT: FGJ.ClassTable) -> FrozenList[FGJ.Type]:
    """
    Returns the D while substituting ts in every step.
    """
    if C == D:
        return ts
    if D != "Object" and D not in CT:
        return genericSupertype(C, ts, env[FGJ.TypeVar(D)].name, env, CT)
    elif C not in CT:
        return genericSupertype(env[FGJ.TypeVar(C)].name, ts, D, env, CT)
    else:
        class_def = CT[C]
        ys = list(class_def.generic_type_annotation.keys())
        superclass = class_def.superclass
        Cprime = superclass.name
        ms = superclass.types
        return genericSupertype(Cprime, FrozenList([AUX.substitute_typeVars(ts, ys, m) for m in ms]), D, env, CT)


# genericSuperType as List
def genericSupertypeList(C: str, ts: FrozenList[FGJ.Type], D: str, env: FGJ.Delta, CT: FGJ.ClassTable) -> list[FGJ.Type]:
    """
    Returns a list of all classes N for C <: N <: D while substituting ts in every step
    """
    if C == D:
        return [FGJ.NonTypeVar(D, ts)]
    elif C not in CT:
        return [FGJ.NonTypeVar(C, ts)] + genericSupertypeList(env[FGJ.TypeVar(C)].name, ts, D, env, CT)
    else:
        class_def = CT[C]
        ys = list(class_def.generic_type_annotation.keys())
        superclass = class_def.superclass
        Cprime = superclass.name
        ms = superclass.types
        tsPrime = FrozenList([AUX.substitute_typeVars(ts, ys, m) for m in ms])
        return [FGJ.NonTypeVar(C, ts)] + genericSupertypeList(Cprime, tsPrime, D, env, CT)


def isSubtypeByName(C: str, D: str, env: FGJ.Delta, CT: FGJ.ClassTable) -> bool:
    """
    Checks if C is subrelated to D only by name
    """
    if D == "Object":
        return True
    if C == "Object":
        return False
    if C == D:
        return True
    if D not in CT:
        return isSubtypeByName(C, env[FGJ.TypeVar(D)].name, env, CT)
    if C not in CT:
        return isSubtypeByName(env[FGJ.TypeVar(C)].name, D, env, CT)
    return isSubtypeByName(CT[C].superclass.name, D, env, CT)


def findCircle(start: FGJ_GT.TypeVarA, a: FGJ_GT.TypeVarA, b: FGJ_GT.TypeVarA, C: FGJ_GT.C) -> list[FGJ_GT.SubTypeC]:
    """
    Checks a < b and b <* a.
    If True: Returns a list of all involved TypeVarAs
    """
    if start == b:
        return [FGJ_GT.SubTypeC(a, b)]
    for constraint in C:
        match constraint:
            case FGJ_GT.SubTypeC(FGJ_GT.TypeVarA(bprime), FGJ_GT.TypeVarA(c)) if b == constraint.t1:
                circle = findCircle(start, FGJ_GT.TypeVarA(bprime), FGJ_GT.TypeVarA(c), C)
                if circle:
                    return [FGJ_GT.SubTypeC(a, b)] + circle
    return []


def isConnected(a: FGJ_GT.TypeVarA, b: FGJ_GT.TypeVarA, C: FGJ_GT.C) -> bool:
    """
    Checks a <* b
    """
    if a == b:
        return True
    for constraint in C:
        match constraint:
            case FGJ_GT.SubTypeC(FGJ_GT.TypeVarA(aPrime), FGJ_GT.TypeVarA(c)) if a == FGJ_GT.TypeVarA(aPrime) and constraint.t1 != constraint.t2:
                if isConnected(FGJ_GT.TypeVarA(c), b, C):
                    return True
    return False


def TypeVarToNonTypeVar_single(t: FGJ.Type) -> FGJ.Type:
    """
    X -> X<>
    """
    match t:
        case FGJ_GT.TypeVarA():
            return t
        case FGJ.TypeVar(name):
            return FGJ.NonTypeVar(name, FrozenList())
        case FGJ.NonTypeVar(name, ts):
            return FGJ.NonTypeVar(name, FrozenList(TypeVarToNonTypeVar_single(ti) for ti in ts))
    raise Exception("CANT GO HERE - BUT TYPECHECKER")


def TypeVarToNonTypeVar(C: set[FGJ_GT.sc]) -> set[FGJ_GT.sc]:
    """
    Xs -> X<>s
    """
    newC_prime: set[FGJ_GT.EqualC | FGJ_GT.SubTypeC] = set()
    for c in C:
        match c:
            case FGJ_GT.EqualC(t1, t2):
                newC_prime.add(FGJ_GT.EqualC(TypeVarToNonTypeVar_single(t1), TypeVarToNonTypeVar_single(t2)))
            case FGJ_GT.SubTypeC(t1, t2):
                newC_prime.add(FGJ_GT.SubTypeC(TypeVarToNonTypeVar_single(t1), TypeVarToNonTypeVar_single(t2)))
    return newC_prime


def NonTypeVarToTypeVar_single(t: FGJ.Type, env: FGJ.Delta) -> FGJ.Type:
    """
    X<> -> X
    """
    match t:
        case FGJ_GT.TypeVarA():
            return t
        case FGJ.TypeVar():
            return t
        case FGJ.NonTypeVar(name, FrozenList()) if FGJ.TypeVar(name) in env:
            return FGJ.TypeVar(name)
        case FGJ.NonTypeVar(name, ts):
            return FGJ.NonTypeVar(name, FrozenList(NonTypeVarToTypeVar_single(ti, env) for ti in ts))
    raise Exception("CANT GO HERE - BUT TYPECHECKER")


def NonTypeVarToTypeVar(C: set[FGJ_GT.sc], env: FGJ.Delta) -> set[FGJ_GT.sc]:
    """
    X<>s -> Xs
    """
    newC_prime2: set[FGJ_GT.EqualC | FGJ_GT.SubTypeC] = set()
    for constraint in C:
        match constraint:
            case FGJ_GT.EqualC(t1, t2):
                newC_prime2.add(FGJ_GT.EqualC(NonTypeVarToTypeVar_single(t1, env), NonTypeVarToTypeVar_single(t2, env)))
            case FGJ_GT.SubTypeC(t1, t2):
                newC_prime2.add(FGJ_GT.SubTypeC(NonTypeVarToTypeVar_single(t1, env), NonTypeVarToTypeVar_single(t2, env)))
    return newC_prime2


def getTypeSigOf(method_sign: FGJ.MethodSign, ysEps: dict[FGJ.TypeVar, FGJ.NonTypeVar], sig: dict[FGJ_GT.TypeVarA, FGJ.TypeVar]) -> dict[FGJ.TypeVar, FGJ.NonTypeVar]:
    set_of_typevars = allTypesIn(sig[method_sign.return_type])
    for arg in method_sign.types_of_arguments:
        set_of_typevars |= allTypesIn(sig[arg])
    changing = True
    while changing:
        changing = False
        for typevar in set_of_typevars.copy():
            if typevar not in ysEps:
                continue
            upperB = ysEps[typevar]
            allTypesInSet = allTypesIn(upperB)
            if not allTypesInSet.issubset(set_of_typevars):
                set_of_typevars |= allTypesIn(upperB)
                changing = True
    return {tv: ysEps[tv] for tv in set_of_typevars if tv in ysEps}


def allTypesIn(type: FGJ.Type) -> set[FGJ.TypeVar]:
    match type:
        case FGJ.TypeVar(_):
            return {type}
        case FGJ.NonTypeVar(_, types):
            out = set()
            for t in types:
                out |= allTypesIn(t)
            return out
        case _:
            return set()
